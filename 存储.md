<!--
 * @Author: 谢树宏
 * @Date: 2022-02-11 11:54:01
 * @LastEditors: 谢树宏
 * @LastEditTime: 2022-02-11 17:54:28
 * @FilePath: /about-study/存储.md
-->

## web 存储

### cookie

1. 大小: 4kb
2. Secure: 设置后 cookie 只能在请求使用 ssl 和 https 协议的时候才会发到服务器
3. Path：这个路径必须出现在要请求的资源路径中才能发送 cookie 首部
4. HttpOnly：设置后 javascript 无法使用 document.cookie 访问
5. SameSite：Strict/Lax 设置为 Lax 后 cookie 不随着跨域请求一起发送，一定程度上可以防止 CSRF 攻击

### cookie 产生的 XSS 和 CSRF 攻击

> XSS(跨站脚本攻击) 类型存储型，反射型，dom 型

1. 注入 1: input 框被写入 script 标签。如：<script>alert('XSS');</script>导致出现注入。解决方法：对特殊字符进行转义。
2. 注入 2： 在标签的 href、src 等属性中，包含 javascript: 等可执行代码

> > 存储型 XSS

攻击者将恶意代码提交到网站的数据库中，用户打开网站时，网站返回恶意代码到浏览器，浏览器解析后拿到 cookie，进行攻击

> > 反射性 XSS

攻击者构造包含恶意的代码的特殊 URL，用户打开带有代码的恶意 url 时，拼接在 html 返回给浏览器，浏览器解析后拿到 cookie，进行攻击

### CSRF 攻击

1. get 请求型

假设目标网站 http://localhost:3000 有三个接口，分别是：

login：登录接口，用户访问后会自动设置 Cookie
balance：查询余额接口
transfer：转账接口，通过 to 和 money 参数控制向谁转钱、转多少钱

如果用户在目标网站上进行了登录操作，获取了 Cookie 凭证，那么下次访问目标网站其他接口的时候，会自动携带 Cookie，CSRF 攻击正是利用了这个特性。

2. post 请求型

跟 get 请求型的过程一样，只是通过

```html
<form
  id="form"
  method="POST"
  enctype="application/x-www-form-urlencoded"
  action="http://localhost:3000/transfer"
  style="display: none"
>
  <input type="text" name="to" value="hacker" />
  <input type="number" name="money" value="100" />
</form>
```

提交

3. 防御手段。1. SameSite，有兼容问题 2. 验证 Origin 和 referer 3. token 机制，放在请求头上面。
