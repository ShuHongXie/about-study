<!--
 * @Author: 谢树宏
 * @Date: 2022-02-09 15:39:11
 * @LastEditors: 谢树宏 384180258@qq.com
 * @LastEditTime: 2022-07-31 22:40:59
 * @FilePath: /about-study/js基础.md
-->

## 面向对象的程序设计

### 原型和原型链。

1.  无论什么时候，只要创建一个构造函数，就会创造一个构造函数本身 prototype 属性，prototype 属性指向构造函数的原型对象，原型对象上默认有一个 constructor 属性指回构造函数
2.  当 new 了一个实例对象之后，每个实例对象都有一个*proto*属性指向构造函数的 prototype 实现继承(即可以访问原型对象的属性和方法)
3.  Object.create(null)新建的对象是没有**proto**属性的
4.  原型链查找对象或方法，先在当前实例查找，没有找到就根据*proto*的指向往原型对象上查找，原型对象上如果没有就往原型链的的*proto*上面查看，直到 Object.prototype.\_proto\_ === null 就表明是原型链的终点。

### 继承

借用构造函数 + 实现新的原型链

## 变量，作用域和内存

### 变量

```js
function setName(obj) {
  obj.name = "Nicholas";
  obj = new Object();
  obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"
```

1. 普通类型的数据，作为参数进入函数时会被赋值一份。不影响原来数据
2. 象类型的数据，一旦传入函数之中，按引用传递，如果被重定向了 会被认为是局部函数，执行完会被销毁

### 类型检测

typeof：判断数据类型 运算符符返回 undefined, boolean, string, object, number, function, symbol

instanceof: typeof 无法用于检测引用类型的值，所以使用 instanceof 来检测是比较好的结果。 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

Object.prototype.toString.call(XXX) 用于检测包装类

### 执行环境

1. 每个执行环境都有与其对应的**变量对象**，全局执行环境被认为是 window 对象，所有的全局变量和函数都是作为 window 对象的属性和方法创建的。
2. 执行环境中的代码执行完之后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）
3. 每个函数都会有自己的执行环境，当执行流进入一个函数时，函数会被推入一个环境栈之中，函数执行完之后，环境栈将其弹出(有点像队列的先进先出结构)。代码执行环境中，会创建变量对象的作用域链，作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

4. 执行上下文是 js 执行一段代码时的运行环境

### 垃圾收集(引用计数和标记清除) https://juejin.cn/post/6981588276356317214#heading-6

可达性，可达性，可达性

1. 标记清除：进入函数环境，定义变量时为变量打上标识(翻转某个位，即通过一个二进制位来标识)，离开执行环境时，标记为离开，回收变量。
   缺点：导致内存空间不连续，内存碎片化，分配速度慢

2. 引用计数: 通过标记对象的引用次数来判断是否要回收
   缺点：容易导致循环引用

```js
function test() {
  let A = new Object();
  let B = new Object();

  A.b = B;
  B.a = A;
}
```

3. V8 垃圾回收优化： 分代式垃圾回收,V8 将垃圾回收分成新，老生代区域。新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。

### 新生代的垃圾回收

新生代(容量 1-8M)中的垃圾回收：新生代将堆内存分为空闲区和使用区，新生代中的对象为存活时间较短的对象，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。

首先，新加入的对象会被放到使用区，当使用区快满的时候，会执行一次垃圾清理操作，当开始进行垃圾收集时，新生代的垃圾回收器会对使用区的活动对象做一次标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。

另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配

### 老生代的垃圾回收

老生代的对象都是比较大的对象，不太适合使用类似新生代的标记复制。而是使用标记清除算法

### 为什么要使用分代式垃圾回收

1. 使用了并行回收，垃圾清除时会额外开启多个辅助线程辅助回收
2. 并发回收，可以再主线程执行空闲时，执行垃圾回收工作

具体看https://juejin.cn/post/6981588276356317214#heading-6

### 事件流

事件流顺序 事件捕获阶段 => 处于目标阶段 => 事件冒泡阶段

stopPropagation() 取消冒泡
