<!--
 * @Author: 谢树宏
 * @Date: 2022-02-14 09:10:06
 * @LastEditors: 谢树宏
 * @LastEditTime: 2022-02-14 17:15:17
 * @FilePath: /about-study/http缓存.md
-->

### 强缓存

1. Expires：HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比，缺点：系统时间和服务器时间不准会引起缓存失效
2. Cache-Control：http1.1 新增，有以下属性
   1. max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效
   2. no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜
   3. no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源
   4. private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应
   5. public：响应可以被中间代理、CDN 等缓存
   6. must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证
3. Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。

### get 和 post 区别

GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。

从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。

从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。

从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。

### http 进化过程

http1.0
特点：每一个 http 连接都要经过经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接

http1.1
特点：采用文本形式传输，针对 http1.0 增加了 keep-alive 持久连接，即一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持，浏览器针对同个域名一次最多可以发起 6 个 tcp 连接

缺点：

1. 虽然增加了持久连接 但是需要等待前面的请求返回之后，才能进行下一次连接，这样会造成对头阻塞问题。
2. 慢启动和 TCP 连接之间相互竞争带宽，这是 http 特性导致的
3. 头部冗余，采用文本格式, 且每一个请求都会带上 cookie、user-agent 等完全相同的首部。头部占用过大数据

http2.0

特点：采用二进制格式传输数据

1. 针对 http1.1 队头阻塞提供了**二进制分帧伟基础的多路复用**机制，一个域名只使用一个 TCP 连接和消除队头阻塞问题
2. 可以设置请求的优先级
3. 服务器主动推送
4. HPACK 头部压缩，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。

### 三次握手

https://juejin.cn/post/6844903958624878606

第一次握手：客户端发送给服务端一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端属于 SYNC_SEND 状态

此时: 首部的同步位 SYN=1，初始序号 seq=x，SYN=1 的报文段不能携带数据，但要消耗掉一个序号

问题：ISN 为什么要随机生成? 不能从 1 开始，如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。

第二次握手：服务端接收到客户端的连接请求之后，会以自己的 SYN 报文作为应答指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态

此时: SYN=1，ACK=1，确认号 ack=x+1，初始序号 seq=y

**重点：此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。这里在补充一点关于 SYN-ACK 重传次数的问题：
服务器发送完 SYN-ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......**

第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1（初始为 seq=x，第二个报文段所以要+1），ACK 报文段可以携带数据，不携带数据则不消耗序号。
。

问题：

1. 为什么一定要三次握手, 不能 2 次吗？ 假如是两次的情况下，客户端发送了 2 个连接请求，发第一个的时候因为网络问题暂时丢包了，再发了第二个。第二个服务端接收到了，返回了连接。此时第一个因为网络问题，最后才到达，服务端发现有请求了，就会发送一次无效的应答请求，浪费了资源
2. 三次握手过程中可以携带数据吗？ 第一次、第二次握手不可以携带数据，因为这会让服务器更加容易受到攻击，持续性的在第一二次中塞入大量数据，会浪费掉服务器的处理资源，导致服务器奔溃
3. SYN 攻击是什么？SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

### 四次挥手

第一次挥手：客户端发送一个 FIN 报文，初始化序列号 seq=u，此时客户端处于 FIN_WAIT1。即 即发出连接释放报文段（FIN=1，序号 seq=u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。

第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1，序号 seq=v），服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。

**收到一个 FIN 只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入 TIME_WAIT 是正常的，服务端通常执行被动关闭，不会进入 TIME_WAIT 状态。**

问题：挥手为什么需要 4 次？

因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，"你发的 FIN 报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。

### https

为什么诞生? 因为 http 本身是明文传输的，不安全，接收方和发送方并不会验证报文的完整性

#### 对称加密和非对称加密搭配使用。数据传输阶段使用对称加密，对称加密的秘钥采用非对称加密

1. ⾸先是 tcp 的三次握⼿建⽴连接
1. client 发送 random1+⽀持的加密算法集合（clientHello）
1. server 收到信息，返回选择⼀个加密算法+random2（serverHello）+ 证书+ 确认
1. clent 验证证书有效性，并⽤ random1+random2 ⽣成 pre-master 通过服务器公钥加密 发送给 server
1. server 收到 premaster，根据约定的加密算法对 random1+random2+premaster（解密）⽣成 master-s ecret，然后发送预定成功
1. client 收到⽣成同样的 master-secert，对称加密秘钥传输完毕

#### 引入 CA 数字证书解 DNS 劫持问题
