<!--
 * @Author: 谢树宏
 * @Date: 2022-02-14 09:10:06
 * @LastEditors: 谢树宏 384180258@qq.com
 * @LastEditTime: 2022-07-26
 * @FilePath: /about-study/浏览器工作原理.md
-->

### 谷歌浏览器的进程线程

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该
程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的
一个运行环境叫进程。

进程：

1. 浏览器主进程，显示渲染进程的生成的图片，下载资源，管理 IPC
2. 渲染进程，
3. GPU 进程，
4. 插件进程，
5. 网络进程

渲染进程中的线程

1. GUI 线程：解析 HTML，CSS，构建 DOM 树和 Render 树，布局和绘制等 （GUI 和 JS 引擎互斥）
2. JS 引擎线程
3. 事件触发器线程, 事件循环
4. http 异步请求线程

### 输入 url 到浏览器渲染做了啥

1. 用户输入 url,构建请求
2. 浏览器进程会通过进程间通信（IPC）把 URL 请求发送⾄⽹络 进程，网络进程会查找缓存，(强缓存，协商缓存)，有缓存就直接返回资源给浏览器进程
3. DNS 解析，等待 tcp 队列队列，Chrome 有个机制，同⼀个域名同时最多只能建⽴ 6 个 TCP 连接
4. 建立 tcp 连接，构建请求头，发送请求头信息，发送 http 请求
5. 如果返回 301，302，网络进程会从请求头里面获取 location，读取 https 或 http 请求，又重复从第 2 步开始
6. 默认情况一个标签页一个渲染进程，准备渲染进程。ps：如果从当前页面打开一个新页面，新页面和当前页面属于同一个站点，那么就会复用父页面的渲染进程。
7. 提交文档，渲染进程准备好后，浏览器进程向渲染进程发起“提交⽂档”的消息，渲染进程接收到消息和⽹络进程建 ⽴传输数据的“管道”，渲染进程接收完数据后，向浏览器发送“确认提交”，浏览器进程接收到确认消息后更新浏览器界⾯状态：安全、地址栏 url、前进后退的历史状态、更新 w eb ⻚⾯
8. 进入渲染了，首先会构建 DOM 树，
9. 构建 cssom 树，样式计算以当渲染引擎接收到 CSS ⽂本时，会执⾏⼀个转换操作，将 CSS ⽂本转换为 stylesheet,随后将 stylesheet 标准化(比如 em 转换成 px, blue 转换成 rgba 格式)

10. 构建 layout 树，计算出 DOM 树中可⻅元素的⼏何位置
11. 分层，绘制，合成线程随后统一栅格化，栅格化后合成线程发送 DrawQuad 给浏览器进程，浏览器进程里面有一个 viz 组件，将其⻚⾯内容绘制到内存中，最后再将内存显⽰在屏幕上
    重排重绘 css：https://blog.csdn.net/guoqiankunmiss/article/details/108454062

#### 注意点：

1. css 不会阻塞 dom 解析，但是会阻塞页面渲染，css 会阻塞 js 的执行
2. JS 引擎执行时 GUI 线程会被挂起，GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时 GUI 线程就执行队列中的 UI 更新。览器无法知晓 JS 的具体内容，倘若先解析 DOM，万一 JS 内部全部删除掉 DOM，那么浏览器就白忙活了，所以就干脆暂停解析 DOM，等到 JS 执行完成再继续解析
3. 浏览器在解析 dom 的时候，会预先加载具有引用标记的外部资源（例如带有 src 标记的<script>标签），等待解析到标签时，无需进行加载，直接运行提高效率

#### async 和 defer

1. 如果 src 所链接的外部资源没有 async，那么当执行到 script 标签时，dom 解析会暂停，直到 src 下载，执行完才继续解析 dom 树
2. 如果 src 所链接的外部资源存在 async，那么 script 标签下载阶段不会阻塞 dom 树的下载，但是执行阶段同样会阻塞 dom 树下载
3. 如果 src 所链接的外部资源存在 defer，那么 script 标签下载阶段会不会阻塞 dom 树的下载，资源会等到 dom 树解析完才执行

https://juejin.cn/post/6894629999215640583

### preload 预加载 和 prefetch 预提取

prefetch：标识了 prefetch 之后会在浏览器空闲时预先获取将来可能访问的文档，存储在缓存之, 等到下一次使用时立即加载，增加加载速度
preload：标识了哪一些资源是在加载后立即需要使用的，可以再浏览器的主渲染机制介入前就进行预加载，这样可以让资源更早地加载，不阻塞页面的初步渲染，提高性能

各自的使用场景：
prefetch：一些异步的 js 模块，大概率会被访问到的资源
preload：隐藏在脚本、样式中的首屏关键资源，建议使用 preload

### html 页面的生命周期

1. DOMContentLoaded：浏览器已经完全加载了 HTML，DOM 树已经构建完毕，但是像是 <img>和样式表等外部资源可能并没有下载完毕。
2. load： 浏览器已经加载了所有的资源（图像，样式表等）。
3. beforeunload：离开时触发
4. unload：离开时触发

### 为什么 css 动画比 js 动画高效
