## react 事件(v16+版本)

### 事件介绍

react 并不是把事件绑定在 div 的真实 dom 上，而是在 document 处监听所有支持的事件，当事件发生冒泡到 document 处时，react 将事件内容封装并交由真正的处理函数运行。除此之外，冒泡到 document 上的事件也不是原生的浏览器事件，而是由 react 自己实现的合成事件（SyntheticEvent）。

### 合成事件的目的

1. 解决了浏览器见的兼容问题，赋予跨端开发能力
2. 使用一个事件池专门来管理和维护时间的创建和销毁，复用对象

### 阻止事件冒泡方法

1. 涉及到原生事件注册时只有 react 事件，用 e.stopPropagation()阻止冒泡

```js
import React, { Component } from "react";
import "./App.css";

class App extends Component {
  handleClickTestBox2 = (e) => {
    console.warn("handleClickTestBox2: ", e);
  };

  handleClickTestBox3 = (e) => {
    e.stopPropagation();
    console.warn("handleClickTestBox3: ", e);
  };

  render() {
    return (
      <div onClick={this.handleClickTestBox2}>
        <div onClick={this.handleClickTestBox3}></div>
      </div>
    );
  }
}

export default App;
```

2. 当用 document.addEventListener 注册了原生的事件后，用 e.stopPropagation()是不能阻止与 document 之间的冒泡，这时候需要用到 e.nativeEvent.stopImmediatePropagation()方法

```js
class App extends Component {
  componentDidMount() {
    document.addEventListener("click", this.handleDocumentClick, false);
  }

  handleDocumentClick = (e) => {
    console.log("handleDocumentClick: ", e);
  };

  handleClickTestBox2 = (e) => {
    console.warn("handleClickTestBox2: ", e);
  };

  handleClickTestBox3 = (e) => {
    // 阻止合成事件的冒泡
    e.stopPropagation();
    // 阻止与原生事件的冒泡
    e.nativeEvent.stopImmediatePropagation();
    console.warn("handleClickTestBox3: ", e);
  };

  render() {
    return (
      <div onClick={this.handleClickTestBox2}>
        <div onClick={this.handleClickTestBox3}></div>
      </div>
    );
  }
}

export default App;
```
