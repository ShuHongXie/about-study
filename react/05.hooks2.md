### useEffect 和 useLayoutEffect 的区别

https://juejin.cn/post/6844904008402862094

### useRefs

useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在

具体看 https://juejin.cn/post/6950464567847682056#heading-8

### ahooks 中 useRefs 演化的 useMemoizedFn 方法解析

```ts
function useMemoizedFn<T extends noop>(fn: T) {
  // 每一次进入当前逻辑都会创建一个useRef的引用
  const fnRef = useRef<T>(fn);

  // why not write `fnRef.current = fn`?
  // https://github.com/alibaba/hooks/issues/728
  // 这一句官方issue上说是为了解决react devtool上无效问题，这段代码实际上没有任何意义
  fnRef.current = useMemo(() => fn, [fn]);

  // 做了一个缓存引用
  const memoizedFn = useRef<PickFunction<T>>();
  // 判断条件内已经做了一层引用了，当新的进来之后，当前memoizedFn已经有了一层引用，所以会使用缓存之前的fnRef
  if (!memoizedFn.current) {
    memoizedFn.current = function (this, ...args) {
      return fnRef.current.apply(this, args);
    };
  }

  return memoizedFn.current;
}
```
