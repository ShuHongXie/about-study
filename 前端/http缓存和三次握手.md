<!--
 * @Author: 谢树宏
 * @Date: 2022-02-14 09:10:06
 * @LastEditors: 谢树宏 384180258@qq.com
 * @LastEditTime: 2022-07-30 21:56:31
 * @FilePath: /about-study/http缓存.md
-->

### 强缓存 返回 200

1. Expires：HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比，缺点：系统时间和服务器时间不准会引起缓存失效
2. Cache-Control：http1.1 新增，有以下属性
   1. max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效
   2. no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜
   3. no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源
   4. private：只能被浏览器缓存，中间代理、CDN 等不能缓存此响应
   5. public：响应可以被中间代理、CDN 等缓存
   6. must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证
3. Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。

### 协商缓存 返回 304

1.请求时携带着 if-modified-since，和响应回来 last-modified 做对比，如果相同，则表示未过期。缺点：1. 因为是通过文件的最后修改时间来判断，如果请求的文件进行了编辑，但内容并没发生任何变化，时间戳也会更新，从而导致协商缓存失效。 2. 其次标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成.那将会无法识别更新

2.请求时携带 if-none-match, 返回时携带 etag，类似于 webpack 的文件指纹策略
缺点：1. 随着文件越来越大，生成 eTag 的时间会越来越久，会造成服务器开销，2.eTag 字段分为前验证和弱验证，弱验证则根据资源的部分属性值来生产，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下也会因为不够准确而降低协商缓存有效验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式

### 301,302 区别

301 表示旧地址 A 的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址

302 表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址。

**http 劫持**，302 跳转时主机服务器的隐含意思是网址 A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到 302 重定向时，一般只要去抓取目标网址就可以了，也就是说网址 B。如果搜索引擎在遇到 302 转向时，百分之百的都抓取目标网址 B 的话，就不用担心网址 URL 劫持了。问题就在于，有的时候搜索引擎，尤其是 Google，并不能总是抓取目标网址。比如说，有的时候 A 网址很短，但是它做了一个 302 重定向到 B 网址，而 B 网址是一个很长的乱七八糟的 URL 网址，甚至还有可能包含一些问号之类的参数

### get 和 post 区别

GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。

从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。

从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。

从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。

### http 进化过程

http1.0
特点：1.引入 cache 机制 If-Modified-Since,Expires 2.引入状态码  
缺点: 但是每一个 http 连接都要经过经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接

http1.1
特点：

1. 采用文本形式传输，针对 http1.0 增加了 keep-alive 持久连接（通过管线化实现），即一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持，浏览器针对同个域名一次最多可以发起 6 个 tcp 连接
2. 引入 etag，if-none-match

缺点：

1. 虽然增加了持久连接 connection:keep-alive 但是需要等待前面的请求返回之后，才能进行下一次连接，这样会造成队头阻塞问题。
2. 慢启动和 TCP 连接之间相互竞争带宽，这是 http 特性导致的
3. 头部冗余，采用文本格式, 且每一个请求都会带上 cookie、user-agent 等完全相同的首部。头部占用过大数据

http2.0

特点：采用二进制格式传输数据

1. 针对 http1.1 队头阻塞提供了**二进制分帧为基础的多路复用**机制，一个域名只使用一个 TCP 连接和消除队头阻塞问题。在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。
2. 可以设置请求的优先级 ，HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题
3. 服务器主动推送
4. HPACK 头部压缩，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。

### 三次握手

syn 洪水攻击 https://blog.csdn.net/weixin_43214644/article/details/125514783

https://blog.csdn.net/weixin_43901866/article/details/104002207

https://juejin.cn/post/6844903958624878606

第一次握手：客户端发送给服务端一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端属于 SYNC_SEND 状态

此时: 首部的同步位 SYN=1，初始序号 seq=x，SYN=1 的报文段不能携带数据，但要消耗掉一个序号

问题：ISN 为什么要随机生成? 不能从 1 开始，如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。

第二次握手：服务端接收到客户端的连接请求之后，会以自己的 SYN 报文作为应答指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态

此时: SYN=1，ACK=1，确认号 ack=x+1，初始序号 seq=y

**重点：此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。这里在补充一点关于 SYN-ACK 重传次数的问题：
服务器发送完 SYN-ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......**

第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1（初始为 seq=x，第二个报文段所以要+1），ACK 报文段可以携带数据，不携带数据则不消耗序号。
。

问题：

1. 为什么一定要三次握手, 不能 2 次吗？ 假如是两次的情况下，客户端发送了 2 个连接请求，发第一个的时候因为网络问题暂时丢包了，再发了第二个。第二个服务端接收到了，返回了连接。此时第一个因为网络问题，最后才到达，服务端发现有请求了，就会发送一次无效的应答请求，浪费了资源
2. 三次握手过程中可以携带数据吗？ 第一次、第二次握手不可以携带数据，因为这会让服务器更加容易受到攻击，持续性的在第一二次中塞入大量数据，会浪费掉服务器的处理资源，导致服务器奔溃
3. SYN 攻击是什么？SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

### 四次挥手

第一次挥手：客户端发送一个 FIN 报文，初始化序列号 seq=u，此时客户端处于 FIN_WAIT1。即 即发出连接释放报文段（FIN=1，序号 seq=u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。

第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1，序号 seq=v），服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。

**收到一个 FIN 只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入 TIME_WAIT 是正常的，服务端通常执行被动关闭，不会进入 TIME_WAIT 状态。**

问题：挥手为什么需要 4 次？

因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，"你发的 FIN 报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。

### https

为什么诞生? 因为 http 本身是明文传输的，不安全，接收方和发送方并不会验证报文的完整性

1. 信息加密
2. 完整性校验
3. 身份验证

https://juejin.cn/post/6844904127420432391#heading-5

#### 对称加密和非对称加密搭配使用。数据传输阶段使用对称加密，对称加密的秘钥采用非对称加密

0. ⾸先是 tcp 的三次握⼿建⽴连接
1. 用户在浏览器发起 HTTPS 请求（如 juejin.cn），默认使用服务端的 443 端口进行连接；
2. HTTPS 需要使用一套 CA 数字证书，证书内会附带一个公钥 Pub，而与之对应的私钥 Private 保留在服务端不公开；
3. 服务端收到请求，返回配置好的包含公钥 Pub 的证书给客户端；
4. 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示 HTTPS 警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的随机 Key，并用证书内的公钥 Pub 进行加密，发送给服务端；
   服务端收到随机 Key 的密文，使用与公钥 Pub 配对的私钥 Private 进行解密，得到客户端真正想发送的随机 Key；
6. 服务端使用客户端发送过来的随机 Key 对要传输的 HTTP 数据进行对称加密，将密文返回客户端；
   客户端使用随机 Key 对称解密密文，得到 HTTP 数据明文；
   后续 HTTPS 请求使用之前交换好的随机 Key 进行对称加解密。

#### 引入 CA 数字证书解 DNS 劫持问题

增加
